#import "../module/module.typ": *
#show: module

在平直空间经常混合线性和仿射. 类似地, 在平直空间, 多项式也是如此. 零阶多项式对应着仿射的使用

先处理一维实数的情况

$ℕ$ 指数幂函数 $k ∈ ℕ, map(ℝ, ℝ, v, v^k)$ 

#tag("polynomial-function-1d") 多项式函数是幂函数的有限线性组合. (仿射) 基点 $x$, (向量) 偏移 $v$
$
  f(x+v) 
  &= a_0 + a_1 v + ⋯ + a_n v^n \
  &= sum_(k = 0 .. n) a_k v^k \

  f(x) &= a_0
$
多项式函数表示并不是仿射不变的, i.e. 切换基点 $x ⇝ x + Δ = y$ 会得到相同阶数但系数不同的多项式函数表示. 伸缩 $v ⇝ λ v$ 也是如此



#tag("change-base-point-polynomial") 切换基点 $x ⇝ x + Δ = y$
$
  f(x + v) &= a_0 (x) + a_1 (x) v + ⋯ + a_n (x) v^n \
  f(y + w) &= a_0 (y) + a_1 (y) w + ⋯ + a_n (y) w^n
$
表示相同的仿射函数
$
  x + v = y + w ==> f(x + v) = f(y + w)
$
则
$
  a_p (y) 
  &= a_p (x + Δ) \
  &= sum_(k = p .. n) a_k (x) binom(k,p) Δ^(k-p)
$
_Proof_ $f(y + v) = f(x + (Δ + v))$ 展开计算, 为对比系数, 收集 $v$ 幂函数项, by 求和的交换 

$
  sum_(k = 0 .. n) a_k (x) (v + Δ)^k 
  &= sum_(k = 0 .. n) a_k (x) sum_(p= 0 .. k) binom(k,p) v^p Δ^(k-p) \
  &= sum_(p = 0 .. n) (sum_(k = p .. n) a_k (x) binom(k,p) Δ^(k-p)) v^k
$

如果在坐标中以 $0$ 为基点 and 改用符号 $v ⇝ x$, 则多项式函数表示为 $f(x) = a_0 + a_1 x + ⋯ + a_n x^n$

从多项式 as 有限线性组合推广到可数无限线性组合, 称为函数的 $ℕ$ 指数幂级数
$
  f(x+v) &≈ a_0 + a_1 v + ⋯ + a_n v^n \
  f(x+v) &= lim_(n -> ∞) a_0 + a_1 v + ⋯ + a_n v^n
$
有些函数的定义并不直接来自 $ℕ$ 指数幂级数, *Example* $1/x , 1/z$

除了 $ℕ$ 作为可数无限数据, 还可以用 $ℤ, ℚ$. $ℕ$ 指数幂函数 $v^k$ 改为 $ℚ$ 指数幂函数 $v^(p/q)$

  - $v^(-k) = 1/v^k$ 需要乘法逆

  - $v^(1/k) = root(k,v)$ 需要解方程 $w^k = v$ 且需要处理解的数量是否唯一的问题

  - $v^(-k)$ 在 $v = 0$ 无界
  
  - $p/q ∉ ℕ$ 时, 多次导数不会中断 $forall n, (v^(p/q) ⇝ p/q ⋯ (p/q - n + 1) v^(p/q - n) != 0)$

这里暂时只处理 $ℕ$ 幂级数, 并简称幂级数

现在处理高维的情况 i.e. $ℝ^d → ℝ^d'$

如果值域是 $ℝ$ 则还可以额外定义函数的乘法 $(f g)(x) = f(x) g(x)$ 和乘法逆 $(1/f)(x) = 1/f(x)$

首先尝试将多项式函数和幂级数的定义基于张量 i.e. 多重线性
$
  ⨂_(k = 0 .. n) ℝ^d
$
如无必要, 暂时不需要对所有阶的张量取线性直和 $⨁_(n = 0 .. ∞)$ (被称为张量代数)

#tag("polynomial-function") 使用值域 $ℝ^d'$ 和多重线性函数 $a_k ∈ Lin((ℝ^d)^(⊗ k) → ℝ^d')$. 基点 $x$, 偏移 $v$, 定义多项式函数
$
  f(x+v) 
  &= a_0 + a_1 v + ⋯ + a_n v^(⊗ n) \
  &= sum_(0 .. n) a_k v^(⊗ k) \

  f(x) &= a_0
$
仿射变换, 即, 改变基点 i.e. 平移, 或者线性变换 i.e. $GL$ (包括了伸缩), 都不改变多项式的阶数

$a_1 v, a_2 v^(⊗ 2) ∈ ℝ^d'$ 可能不共线

推广到 $ℂ$ 是简单的. $ℍ,𝕆$ 的情况, 由于非交换和非结合, 高维线性代数和张量都需要新的处理方法

可能有不同的张量给出相同的多项式, 但是对称张量是唯一对应的

改变记号
- $v^(⊙ k) ⇝ v^k$ #tag("power-tensor")
- $v ⊙ w ⇝ v w$

从 $n$ 阶单项式 or 幂张量 $v^n$ 恢复到 $n$ 阶对称张量 $v_1 ⋯ v_n$ 的方法是, 差分 (difference)

$v_1 + ⋯ + v_n$ 的 $n$ 阶单项式 $(v_1 + ⋯ + v_n)^n$ 中有一项 $v_1 ⋯ v_n$, 但是有很多其它的干扰项

整个问题对 $v_1 ,…, v_n$ 对称, 所以应该用对称的构造

在二阶 $(v_1 + v_2)^2 - v_1^2 - v_2^2 = 2 v_1 v_2$

#tag("difference-symmetric-tensor") 对称张量 $n$ 阶差分
$
  sum_(I ⊆ {1 ,…, n}) (-1)^(|I| - n) (sum_(i ∈ I) v_i)^m = cases(
    0 &"if" m < n ,
    n! ⋅ v_1 ⋯ v_n &"if" m = n ,
    != 0 &"else"
  ) 
$
*Question* $n$ 阶差分有什么直观的理解吗?

#tag("successive-difference") $n$ 阶差分可以写为 $n$ 次的一阶差分
$
  sum_(I_n ⊆ {n}) ⋯ sum_(I_1 ⊆ {1}) (-1)^(|I_n| - 1) ⋯ (-1)^(|I_1| - 1) 
  (sum_(i_1 ∈ I_1) v_(i_1) + ⋯ + sum_(i_n ∈ I_n) v_(i_n))^n
$
where $I_k ⊆ {k} <==> I_k ∈ Subset{k} = {∅,{k}}$, $sum_(i_k ∈ ∅) v_(i_k) = 0$, $I := ⋃_(1 .. n) I_k subset {1 ,…, n}$

由于求和的交换性, 逐次差分的顺序不影响最终结果

_Proof_ of #link(<difference-symmetric-tensor>)[]
#indent[
  $
    sum_(I ⊆ {1 ,…, n}) (-1)^(|I| - n) (sum_(i ∈ I) v_i)^m
    &= sum_(I ⊆ {1 ,…, n}) (-1)^(|I| - n) sum_(μ : {1 ,…, m} -> A) v_(μ(1)) ⋯ v_(μ(m))
  $
  强行写为对所有 $μ : {1 ,…, m} -> {1 ,…, n}$ 求和, 附带 weight 来计算重复次数
  $
    sum_(μ : {1 ,…, m} -> {1 ,…, n}) "weight"(μ) ⋅ v_(μ(1)) ⋯ v_(μ(m))
  $
  where 权重对每个 $μ$ 定义为
  $
    "weight"(μ) = (-1)^n sum_(I in Subset{1 ,…, n} : \ μ{1 ,…, m} ⊆ I) (-1)^(|I|)
  $
  对任何非空有限集 $X$, $sum_(A ⊆ X) (-1)^(|A|) = 0$

  _Proof_
  #indent[
    #link(<combination>)[] $A ⊆ X$ <==> for each $|A| = 0 ,…, |X|$ 有 $binom(|X|,|A|)$ 种选择

    $
      sum_(A ⊆ X) (-1)^(|A|) 
      &= sum_(|A| = 0 .. |X|) binom(|X|,|A|) (-1)^(|A|) \
      &= (1 - 1)^(|X|) \
      &= 0   
    $
  ]
  for ${I ∈ Subset{1 ,…, n} : μ{1 ,…, m} ⊆ I}$

  define $A(I) := I ∖ μ{1 ,…, m}$

  define $X := Subset({1 ,…, n} ∖ μ{1 ,…, m})$ 

  $A(I)$ 是双射
  $
    (-1)^(|I|) 
    &= (-1)^(|I ∖ μ{1 ,…, m}| + |μ{1 ,…, m}|) \
    &= (-1)^(|A|) ⋅ (-1)^(μ{1 ,…, m})
  $
  权重
  $
    "weight"(μ) = (-1)^n ⋅ (-1)^(|μ{1 ,…, m}|) ⋅ sum_(A ⊆ X) (-1)^(|A|)
  $
  $
    "weight"(μ) = 0
    &<==> X != ∅ \
    &<==> μ{1 ,…, m} ⊊ {1 ,…, n}
  $
  最后的条件
  - $m < n$ 时对所有 $μ$ 一定成立
  - $m = n$ 时, 只有 $μ$ 是双射时才成立 i.e. $μ$ 是所有 $n$ 阶置换, 此时 $"weight"(μ) = 1$

  对称张量使得 $v_(μ(1)) ⋯ v_(μ(m)) = v_1 ⋯ v_n$

  $n$ 阶置换有 $n!$ 个
]
*对称* 多重线性函数 $a_m$ 的 *对称性* 使得 #link(<difference-symmetric-tensor>)[差分] 的性质能够被继承

#tag("difference-polynomial") $f(x + v) = a_n v^n$ 的 $n$ 阶差分是 $n! ⋅ a_n (v_1 ⋯ v_n)$

$f(x + v) = a_n v^m, m < n$ 的 $n$ 阶差分是 $0$

由此得到, 多项式函数决定其多重对称线性函数表示 _Proof_ 先 $n$ 差分得到相同的 $a_n$, 两者同时移除 $a_n$ 后, 仍然是相同的多项式函数, 阶数 $< n$, 继续 $n-1$ 差分得到相同的 $a_(n-1)$ ...

对于幂级数, 有限阶差分总是无法给出零

形式上, 可以利用除法和极限来消除高阶项
$
  1/(t^n) (a_n (t v)^n + a_(n+1) (t v)^(n+1) + ⋯) 
  &= a_n v^n + a_(n+1) v^(n+1) t + ⋯ \
  &= a_n v^n + o(1) \
  lim_(t -> 0) 
  &= a_n v^n
$